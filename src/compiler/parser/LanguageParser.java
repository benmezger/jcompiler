/* LanguageParser.java */
/* Generated By:JavaCC: Do not edit this line. LanguageParser.java */
package compiler.parser;

import javax.swing.text.html.parser.Parser;
import java.util.List;
import java.util.ArrayList;
import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.lang.StringBuilder;
import java.lang.StringBuilder;

public class LanguageParser implements LanguageParserConstants {
    int contParseError = 0;
    boolean debugRecovery = true;
    final static List<ErrorStruct> output = new ArrayList<ErrorStruct>();
    boolean eof;

    public static List<Token> getTokens(String stream){
        InputStream target =  new ByteArrayInputStream(stream.getBytes());
        LanguageParser parser = new LanguageParser(target);
        return tokenize(parser);
    }

    public static ArrayList<ErrorStruct> checkSyntax(String stream) {
        InputStream target =  new ByteArrayInputStream(stream.getBytes());
        LanguageParser parser = new LanguageParser(target);
        try {
            parser.begin_program();
            }
        catch (ParseException e){
            output.add(new ErrorStruct("Error parsing the program.\n", e));
        }
        ArrayList tmp = new ArrayList<ErrorStruct>(output);
        output.clear();
        return tmp;
    }

   public static LanguageParser create(String stream){
        InputStream target =  new ByteArrayInputStream(stream.getBytes());
        LanguageParser parser = new LanguageParser(target);
        return parser;
   }

    public static void main(String args[]) throws TokenMgrError, ParseException {
        LanguageParser parser = null;
        if (args.length == 0) {
            parser = new LanguageParser(System.in);
        }
        else if (args.length == 1) {
            try {
                parser = new LanguageParser(new java.io.FileInputStream(args[0]));
            }
            catch (java.io.FileNotFoundException e) {
                System.out.println("LanguageParser: file " + args[0] + " was not found.");
                return;
            }
        }

        //for (Token token: tokenize(parser)){
        //    String name = LanguageParserConstants.tokenImage[token.kind];
        //    System.out.println("Line " + token.beginLine + " | Column " + token.beginColumn + " | " + token + "\n");
        //}
    }

    public static List<Token> tokenize(LanguageParser parser){
        List<Token> tokens = new ArrayList<Token>();

        Token token = parser.getNextToken();
        while (token.kind != LanguageParserConstants.EOF){
            tokens.add(token);
            token = parser.getNextToken();
        }

        if (!TokenHandler.isClosed()){
            tokens.add(TokenHandler.createToken());
        }

        return tokens;
    }

    static public String im(int x){
        String s = tokenImage[x];
        int k = s.lastIndexOf("\"");
        try {
            s = s.substring(1, k);
        }
        catch (StringIndexOutOfBoundsException e){}
        return s;
    }

    public void consumeUntil(RecoverySet g, ParseException e, String met) throws  ParseException {
        Token tok;
        if (g == null){
            throw e;
        }
        tok = getToken(1); // Current token
        while (!eof){
            /* found a token in set */
            if (g.contains(tok.kind)) {
                break;
            }
            getNextToken();
            tok = getToken(1);
            if (tok.kind == EOF && !g.contains(EOF)){
                eof = true;
            }
        }
        contParseError++;
    }

  final public void enum_values() throws ParseException {
    trace_call("enum_values");
    try {

      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case NUM:
      case NUMBER_REAL:
      case STRING_LITERAL:{
        constant_result();
        break;
        }
      case IDENTIFIER:{
        jj_consume_token(IDENTIFIER);
        break;
        }
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("enum_values");
    }
}

  final public void inner_enum_declaration(RecoverySet r) throws ParseException {
    trace_call("inner_enum_declaration");
    try {

      try {
        jj_consume_token(IDENTIFIER);
        jj_consume_token(IS);
        enum_values();
        inner_enum_decla_cont();
        jj_consume_token(DOT);
      } catch (ParseException e) {
consumeUntil(r, e, "Error: Invalid enum declaration syntax.");
           output.add(new ErrorStruct("Erro: declaracao de enum interna incorreta.\n", e));
      }
    } finally {
      trace_return("inner_enum_declaration");
    }
}

  final public void inner_enum_decla_cont() throws ParseException {
    trace_call("inner_enum_decla_cont");
    try {

      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        jj_consume_token(COMMA);
        enum_values();
        inner_enum_decla_cont();
        break;
        }
      default:
        jj_la1[1] = jj_gen;
        ;
      }
    } finally {
      trace_return("inner_enum_decla_cont");
    }
}

  final public void enum_declaration(RecoverySet r) throws ParseException {
    trace_call("enum_declaration");
    try {

      try {
        jj_consume_token(TYPE);
        jj_consume_token(OPEN_BRACKET);
        label_1:
        while (true) {
          inner_enum_declaration(r);
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case IDENTIFIER:{
            ;
            break;
            }
          default:
            jj_la1[2] = jj_gen;
            break label_1;
          }
        }
        jj_consume_token(CLOSE_BRACKET);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case DECLARATION:{
          jj_consume_token(DECLARATION);
          declaration_constants_and_variables(r);
          break;
          }
        default:
          jj_la1[3] = jj_gen;
          ;
        }
      } catch (ParseException e) {
consumeUntil(r, e, "Error: Invalid enum declaration syntax.");
       output.add(new ErrorStruct("Erro: declaracao de enum incorreta.\n", e));
      }
    } finally {
      trace_return("enum_declaration");
    }
}

  final public void identifiers() throws ParseException {
    trace_call("identifiers");
    try {

      jj_consume_token(IDENTIFIER);
      index();
    } finally {
      trace_return("identifiers");
    }
}

  final public void identifiers_list() throws ParseException {
    trace_call("identifiers_list");
    try {

      identifiers();
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[4] = jj_gen;
          break label_2;
        }
        jj_consume_token(COMMA);
        identifiers();
      }
    } finally {
      trace_return("identifiers_list");
    }
}

  final public void type_declaration() throws ParseException {
    trace_call("type_declaration");
    try {

      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case INTEGER:{
        jj_consume_token(INTEGER);
        break;
        }
      case REAL:{
        jj_consume_token(REAL);
        break;
        }
      case STRING:{
        jj_consume_token(STRING);
        break;
        }
      case LOGIC:{
        jj_consume_token(LOGIC);
        break;
        }
      case ENUM:{
        jj_consume_token(ENUM);
        break;
        }
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("type_declaration");
    }
}

  final public void variable_declaration() throws ParseException {
    trace_call("variable_declaration");
    try {

      identifiers_list();
      jj_consume_token(IS);
      type_declaration();
      jj_consume_token(DOT);
    } finally {
      trace_return("variable_declaration");
    }
}

  final public void type_constant() throws ParseException {
    trace_call("type_constant");
    try {

      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case INTEGER:{
        jj_consume_token(INTEGER);
        break;
        }
      case REAL:{
        jj_consume_token(REAL);
        break;
        }
      case STRING:{
        jj_consume_token(STRING);
        break;
        }
      case LOGIC:{
        jj_consume_token(LOGIC);
        break;
        }
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("type_constant");
    }
}

  final public void end_constant() throws ParseException {
    trace_call("end_constant");
    try {

      jj_consume_token(AS);
      jj_consume_token(CONSTANT);
      label_3:
      while (true) {
        constant_declaration();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case IDENTIFIER:{
          ;
          break;
          }
        default:
          jj_la1[7] = jj_gen;
          break label_3;
        }
      }
    } finally {
      trace_return("end_constant");
    }
}

  final public void start_variable() throws ParseException {
    trace_call("start_variable");
    try {

      jj_consume_token(VARIABLE);
      label_4:
      while (true) {
        variable_declaration();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case IDENTIFIER:{
          ;
          break;
          }
        default:
          jj_la1[8] = jj_gen;
          break label_4;
        }
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case AS:{
        end_constant();
        break;
        }
      default:
        jj_la1[9] = jj_gen;
        ;
      }
    } finally {
      trace_return("start_variable");
    }
}

  final public void constant_declaration() throws ParseException {
    trace_call("constant_declaration");
    try {

      identifiers_list();
      jj_consume_token(IS);
      type_constant();
      jj_consume_token(ASSIGN);
      constant_result();
      jj_consume_token(DOT);
    } finally {
      trace_return("constant_declaration");
    }
}

  final public void end_variable() throws ParseException {
    trace_call("end_variable");
    try {

      jj_consume_token(AS);
      jj_consume_token(VARIABLE);
      label_5:
      while (true) {
        variable_declaration();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case IDENTIFIER:{
          ;
          break;
          }
        default:
          jj_la1[10] = jj_gen;
          break label_5;
        }
      }
    } finally {
      trace_return("end_variable");
    }
}

  final public void start_constant() throws ParseException {
    trace_call("start_constant");
    try {

      jj_consume_token(CONSTANT);
      label_6:
      while (true) {
        constant_declaration();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case IDENTIFIER:{
          ;
          break;
          }
        default:
          jj_la1[11] = jj_gen;
          break label_6;
        }
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case AS:{
        end_variable();
        break;
        }
      default:
        jj_la1[12] = jj_gen;
        ;
      }
    } finally {
      trace_return("start_constant");
    }
}

  final public void start_declaration(RecoverySet r) throws ParseException {
    trace_call("start_declaration");
    try {

      try {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case VARIABLE:{
          start_variable();
          break;
          }
        case CONSTANT:{
          start_constant();
          break;
          }
        default:
          jj_la1[13] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } catch (ParseException e) {
consumeUntil(r, e, "Error: Invalid declaration body.\n");
         output.add(new ErrorStruct("Error: Bad start declaration.\n", e));
      }
    } finally {
      trace_return("start_declaration");
    }
}

  final public void inner_declaration(RecoverySet r) throws ParseException {
    trace_call("inner_declaration");
    try {

      try {
        jj_consume_token(AS);
        start_declaration(r);
      } catch (ParseException e) {
consumeUntil(r, e, "Error: Invalid declaration body.\n");
        output.add(new ErrorStruct("Error: Bad inner declaration of as.\n", e));
      }
    } finally {
      trace_return("inner_declaration");
    }
}

  final public void declaration_constants_and_variables(RecoverySet r) throws ParseException {
    trace_call("declaration_constants_and_variables");
    try {

      try {
        jj_consume_token(CONSTANT);
        jj_consume_token(AND);
        jj_consume_token(VARIABLE);
        jj_consume_token(OPEN_BRACKET);
        inner_declaration(r);
        jj_consume_token(CLOSE_BRACKET);
      } catch (ParseException e) {
consumeUntil(r, e, "declaration_constants_and_variables");
        output.add(new ErrorStruct("Error: Bad inner constant and variable declaration.\n", e));
      }
    } finally {
      trace_return("declaration_constants_and_variables");
    }
}

  final public void constant_result() throws ParseException {
    trace_call("constant_result");
    try {

      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case STRING_LITERAL:{
        jj_consume_token(STRING_LITERAL);
        break;
        }
      case NUM:{
        jj_consume_token(NUM);
        break;
        }
      case NUMBER_REAL:{
        jj_consume_token(NUMBER_REAL);
        break;
        }
      default:
        jj_la1[14] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("constant_result");
    }
}

  final public void logic_result() throws ParseException {
    trace_call("logic_result");
    try {

      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case TRUE:{
        jj_consume_token(TRUE);
        jj_consume_token(RESULT);
        jj_consume_token(OPEN_BRACKET);
        list_of_commands();
        jj_consume_token(CLOSE_BRACKET);
        true_result_cont();
        break;
        }
      case UNTRUE:{
        jj_consume_token(UNTRUE);
        jj_consume_token(RESULT);
        jj_consume_token(OPEN_BRACKET);
        list_of_commands();
        jj_consume_token(CLOSE_BRACKET);
        untrue_result_cont();
        break;
        }
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("logic_result");
    }
}

  final public void true_result_cont() throws ParseException {
    trace_call("true_result_cont");
    try {

      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case UNTRUE:{
        jj_consume_token(UNTRUE);
        jj_consume_token(RESULT);
        jj_consume_token(OPEN_BRACKET);
        list_of_commands();
        jj_consume_token(CLOSE_BRACKET);
        jj_consume_token(DOT);
        break;
        }
      case DOT:{
        jj_consume_token(DOT);
        break;
        }
      default:
        jj_la1[16] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("true_result_cont");
    }
}

  final public void untrue_result_cont() throws ParseException {
    trace_call("untrue_result_cont");
    try {

      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case TRUE:{
        jj_consume_token(TRUE);
        jj_consume_token(RESULT);
        jj_consume_token(OPEN_BRACKET);
        list_of_commands();
        jj_consume_token(CLOSE_BRACKET);
        jj_consume_token(DOT);
        break;
        }
      case DOT:{
        jj_consume_token(DOT);
        break;
        }
      default:
        jj_la1[17] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("untrue_result_cont");
    }
}

  final public void declarations(RecoverySet r) throws ParseException {
    trace_call("declarations");
    try {

      try {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case DECLARATION:{
          jj_consume_token(DECLARATION);
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case TYPE:{
            enum_declaration(r);
            break;
            }
          case CONSTANT:{
            declaration_constants_and_variables(r);
            break;
            }
          default:
            jj_la1[18] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
          }
        default:
          jj_la1[19] = jj_gen;
          ;
        }
      } catch (ParseException e) {
consumeUntil(r, e, "declarations");
       output.add(new ErrorStruct("Erro de declara\u00e7\u00e3o de enum/variable\n", e));
      }
    } finally {
      trace_return("declarations");
    }
}

  final public void list_of_commands() throws ParseException {
    trace_call("list_of_commands");
    try {
RecoverySet g = new RecoverySet(DOT);
      try {
        label_7:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case REPEAT:{
            repeat();
            break;
            }
          case AVALIATE:{
            avaliate();
            break;
            }
          case WRITE:{
            jj_consume_token(WRITE);
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case THIS:{
              write();
              break;
              }
            case ALL:{
              write_all();
              break;
              }
            default:
              jj_la1[20] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            break;
            }
          case DESIGNATE:{
            designate();
            break;
            }
          case READ:{
            read();
            break;
            }
          default:
            jj_la1[21] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case DESIGNATE:
          case READ:
          case WRITE:
          case AVALIATE:
          case REPEAT:{
            ;
            break;
            }
          default:
            jj_la1[22] = jj_gen;
            break label_7;
          }
        }
      } catch (ParseException e) {
consumeUntil(g, e, "list_of_commands");
      }
    } finally {
      trace_return("list_of_commands");
    }
}

  final public void expression() throws ParseException {
    trace_call("expression");
    try {

      arithmetic_or_logic_expression();
      expression_cont();
    } finally {
      trace_return("expression");
    }
}

  final public void arithmetic_or_logic_expression() throws ParseException {
    trace_call("arithmetic_or_logic_expression");
    try {

      second_term();
      lesser_priority_operators();
    } finally {
      trace_return("arithmetic_or_logic_expression");
    }
}

  final public void expression_cont() throws ParseException {
    trace_call("expression_cont");
    try {

      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case EQUAL_TO:
      case DIFF_THAN:
      case LESS_THAN:
      case GREATER_THAN:
      case LESS_THAN_OR_EQ_TO:
      case GREATER_THAN_OR_EQ_TO:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case EQUAL_TO:{
          jj_consume_token(EQUAL_TO);
          arithmetic_or_logic_expression();
          break;
          }
        case DIFF_THAN:{
          jj_consume_token(DIFF_THAN);
          arithmetic_or_logic_expression();
          break;
          }
        case LESS_THAN:{
          jj_consume_token(LESS_THAN);
          arithmetic_or_logic_expression();
          break;
          }
        case GREATER_THAN:{
          jj_consume_token(GREATER_THAN);
          arithmetic_or_logic_expression();
          break;
          }
        case LESS_THAN_OR_EQ_TO:{
          jj_consume_token(LESS_THAN_OR_EQ_TO);
          arithmetic_or_logic_expression();
          break;
          }
        case GREATER_THAN_OR_EQ_TO:{
          jj_consume_token(GREATER_THAN_OR_EQ_TO);
          arithmetic_or_logic_expression();
          break;
          }
        default:
          jj_la1[23] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
        }
      default:
        jj_la1[24] = jj_gen;
        ;
      }
    } finally {
      trace_return("expression_cont");
    }
}

  final public void first_term() throws ParseException {
    trace_call("first_term");
    try {

      element();
      top_priority_operators();
    } finally {
      trace_return("first_term");
    }
}

  final public void second_term() throws ParseException {
    trace_call("second_term");
    try {

      first_term();
      medium_priority_operators();
    } finally {
      trace_return("second_term");
    }
}

  final public void element() throws ParseException {
    trace_call("element");
    try {

      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IDENTIFIER:{
        jj_consume_token(IDENTIFIER);
        index();
        break;
        }
      case NUM:{
        jj_consume_token(NUM);
        break;
        }
      case NUMBER_REAL:{
        jj_consume_token(NUMBER_REAL);
        break;
        }
      case STRING_LITERAL:{
        jj_consume_token(STRING_LITERAL);
        break;
        }
      case TRUE:{
        jj_consume_token(TRUE);
        break;
        }
      case UNTRUE:{
        jj_consume_token(UNTRUE);
        break;
        }
      case OPEN_PARENTHESIS:{
        jj_consume_token(OPEN_PARENTHESIS);
        expression();
        jj_consume_token(CLOSE_PARENTHESIS);
        break;
        }
      case LOGICAL_NOT:{
        jj_consume_token(LOGICAL_NOT);
        jj_consume_token(OPEN_PARENTHESIS);
        expression();
        jj_consume_token(CLOSE_PARENTHESIS);
        break;
        }
      default:
        jj_la1[25] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("element");
    }
}

  final public void index() throws ParseException {
    trace_call("index");
    try {

      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case OPEN_CURLY_BRACKETS:{
        jj_consume_token(OPEN_CURLY_BRACKETS);
        jj_consume_token(NUM);
        jj_consume_token(CLOSE_CURLY_BRACKETS);
        break;
        }
      default:
        jj_la1[26] = jj_gen;
        ;
      }
    } finally {
      trace_return("index");
    }
}

  final public void top_priority_operators() throws ParseException {
    trace_call("top_priority_operators");
    try {

      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case POWER:{
          ;
          break;
          }
        default:
          jj_la1[27] = jj_gen;
          break label_8;
        }
        jj_consume_token(POWER);
        element();
      }
    } finally {
      trace_return("top_priority_operators");
    }
}

  final public void medium_priority_operators() throws ParseException {
    trace_call("medium_priority_operators");
    try {

      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case MULTIPLY:
        case DIV:
        case WHOLE_DIV:
        case REST_DIV:
        case LOGICAL_AND:{
          ;
          break;
          }
        default:
          jj_la1[28] = jj_gen;
          break label_9;
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case MULTIPLY:{
          jj_consume_token(MULTIPLY);
          first_term();
          break;
          }
        case DIV:{
          jj_consume_token(DIV);
          first_term();
          break;
          }
        case WHOLE_DIV:{
          jj_consume_token(WHOLE_DIV);
          first_term();
          break;
          }
        case REST_DIV:{
          jj_consume_token(REST_DIV);
          first_term();
          break;
          }
        case LOGICAL_AND:{
          jj_consume_token(LOGICAL_AND);
          first_term();
          break;
          }
        default:
          jj_la1[29] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } finally {
      trace_return("medium_priority_operators");
    }
}

  final public void lesser_priority_operators() throws ParseException {
    trace_call("lesser_priority_operators");
    try {

      label_10:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case PLUS:
        case MINUS:
        case LOGICAL_OR:{
          ;
          break;
          }
        default:
          jj_la1[30] = jj_gen;
          break label_10;
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case PLUS:{
          jj_consume_token(PLUS);
          second_term();
          break;
          }
        case MINUS:{
          jj_consume_token(MINUS);
          second_term();
          break;
          }
        case LOGICAL_OR:{
          jj_consume_token(LOGICAL_OR);
          second_term();
          break;
          }
        default:
          jj_la1[31] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } finally {
      trace_return("lesser_priority_operators");
    }
}

  final public void repeat() throws ParseException {
    trace_call("repeat");
    try {

      jj_consume_token(REPEAT);
      jj_consume_token(THIS);
      expression();
      jj_consume_token(OPEN_BRACKET);
      list_of_commands();
      jj_consume_token(CLOSE_BRACKET);
      jj_consume_token(DOT);
    } finally {
      trace_return("repeat");
    }
}

  final public void avaliate() throws ParseException {
    trace_call("avaliate");
    try {

      jj_consume_token(AVALIATE);
      jj_consume_token(THIS);
      expression();
      logic_result();
    } finally {
      trace_return("avaliate");
    }
}

  final public void write() throws ParseException {
    trace_call("write");
    try {

      jj_consume_token(THIS);
      jj_consume_token(OPEN_BRACKET);
      write_body();
      jj_consume_token(CLOSE_BRACKET);
      jj_consume_token(DOT);
    } finally {
      trace_return("write");
    }
}

  final public void write_all() throws ParseException {
    trace_call("write_all");
    try {

      jj_consume_token(ALL);
      jj_consume_token(THIS);
      jj_consume_token(OPEN_BRACKET);
      write_body();
      jj_consume_token(CLOSE_BRACKET);
      jj_consume_token(DOT);
    } finally {
      trace_return("write_all");
    }
}

  final public void write_body() throws ParseException {
    trace_call("write_body");
    try {

      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case NUM:
      case NUMBER_REAL:
      case STRING_LITERAL:{
        constant_result();
        break;
        }
      case IDENTIFIER:{
        identifiers();
        break;
        }
      default:
        jj_la1[32] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:
        case IDENTIFIER:{
          ;
          break;
          }
        default:
          jj_la1[33] = jj_gen;
          break label_11;
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          jj_consume_token(COMMA);
          constant_result();
          break;
          }
        case IDENTIFIER:{
          identifiers();
          break;
          }
        default:
          jj_la1[34] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } finally {
      trace_return("write_body");
    }
}

  final public void designate() throws ParseException {
    trace_call("designate");
    try {

      jj_consume_token(DESIGNATE);
      jj_consume_token(THIS);
      identifiers_list();
      jj_consume_token(AS);
      expression();
      jj_consume_token(DOT);
    } finally {
      trace_return("designate");
    }
}

  final public void read() throws ParseException {
    trace_call("read");
    try {
RecoverySet g = new RecoverySet(DOT);
      try {
        jj_consume_token(READ);
        jj_consume_token(THIS);
        jj_consume_token(OPEN_BRACKET);
        identifiers_list();
        jj_consume_token(CLOSE_BRACKET);
        jj_consume_token(DOT);
      } catch (ParseException e) {
consumeUntil(g, e, "read");
      }
    } finally {
      trace_return("read");
    }
}

  final public void header(RecoverySet r) throws ParseException {
    trace_call("header");
    try {

      try {
        jj_consume_token(DO);
        jj_consume_token(THIS);
        jj_consume_token(IDENTIFIER);
        jj_consume_token(OPEN_BRACKET);
        jj_consume_token(CLOSE_BRACKET);
      } catch (ParseException e) {
consumeUntil(r, e, "header");
        output.add(new ErrorStruct("Erro: Cabecalho principal incorreto.\n", e));
      }
    } finally {
      trace_return("header");
    }
}

  final public void main(RecoverySet r) throws ParseException {
    trace_call("main");
    try {
RecoverySet h = new RecoverySet(BODY);
        RecoverySet g = new RecoverySet(DECLARATION);
        RecoverySet i = g.union(h);
        RecoverySet l = new RecoverySet(DESCRIPTION);
      try {
        header(i);
        declarations(h);
        jj_consume_token(BODY);
        jj_consume_token(OPEN_BRACKET);
        list_of_commands();
        jj_consume_token(CLOSE_BRACKET);
        jj_consume_token(DESCRIPTION);
        jj_consume_token(STRING_LITERAL);
      } catch (ParseException e) {
consumeUntil(g, e, "main");
      }
    } finally {
      trace_return("main");
    }
}

  final public void begin_program() throws ParseException {
    trace_call("begin_program");
    try {
RecoverySet r = new RecoverySet(EOF);
      try {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case DO:{
          main(r);
          break;
          }
        default:
          jj_la1[35] = jj_gen;
          ;
        }
        jj_consume_token(0);
      } catch (ParseException e) {
consumeUntil(r, e, "begin_program");
        output.add(new ErrorStruct("Erro: Forma geral do programa incorreto.\n", e));
      }
    } finally {
      trace_return("begin_program");
    }
}

  /** Generated Token Manager. */
  public LanguageParserTokenManager token_source;
  JavaCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[36];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
	   jj_la1_init_0();
	   jj_la1_init_1();
	   jj_la1_init_2();
	}
	private static void jj_la1_init_0() {
	   jj_la1_0 = new int[] {0x0,0x0,0x0,0x20000000,0x0,0x80000700,0x700,0x0,0x0,0x40000,0x0,0x0,0x40000,0x300000,0x0,0x1800,0x1000,0x800,0x40100000,0x20000000,0x2004000,0x15c00000,0x15c00000,0x0,0x0,0x1800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000,};
	}
	private static void jj_la1_init_1() {
	   jj_la1_1 = new int[] {0x64000000,0x200000,0x4000000,0x0,0x200000,0x2000000,0x2000000,0x4000000,0x4000000,0x0,0x4000000,0x4000000,0x0,0x0,0x60000000,0x0,0x100000,0x100000,0x0,0x0,0x0,0x0,0x0,0x3e80,0x3e80,0x65010000,0x40000,0x10,0x40006c,0x40006c,0x800003,0x800003,0x64000000,0x4200000,0x4200000,0x0,};
	}
	private static void jj_la1_init_2() {
	   jj_la1_2 = new int[] {0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,};
	}

  {
      enable_tracing();
  }
  /** Constructor with InputStream. */
  public LanguageParser(java.io.InputStream stream) {
	  this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public LanguageParser(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source = new LanguageParserTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 36; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
	  ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 36; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public LanguageParser(java.io.Reader stream) {
	 jj_input_stream = new JavaCharStream(stream, 1, 1);
	 token_source = new LanguageParserTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 36; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
	if (jj_input_stream == null) {
	   jj_input_stream = new JavaCharStream(stream, 1, 1);
	} else {
	   jj_input_stream.ReInit(stream, 1, 1);
	}
	if (token_source == null) {
 token_source = new LanguageParserTokenManager(jj_input_stream);
	}

	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 36; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public LanguageParser(LanguageParserTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 36; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(LanguageParserTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 36; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
	 Token oldToken;
	 if ((oldToken = token).next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 if (token.kind == kind) {
	   jj_gen++;
	   trace_token(token, "");
	   return token;
	 }
	 token = oldToken;
	 jj_kind = kind;
	 throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
	 if (token.next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 jj_gen++;
	   trace_token(token, " (in getNextToken)");
	 return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
	 Token t = token;
	 for (int i = 0; i < index; i++) {
	   if (t.next != null) t = t.next;
	   else t = t.next = token_source.getNextToken();
	 }
	 return t;
  }

  private int jj_ntk_f() {
	 if ((jj_nt=token.next) == null)
	   return (jj_ntk = (token.next=token_source.getNextToken()).kind);
	 else
	   return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
	 jj_expentries.clear();
	 boolean[] la1tokens = new boolean[67];
	 if (jj_kind >= 0) {
	   la1tokens[jj_kind] = true;
	   jj_kind = -1;
	 }
	 for (int i = 0; i < 36; i++) {
	   if (jj_la1[i] == jj_gen) {
		 for (int j = 0; j < 32; j++) {
		   if ((jj_la1_0[i] & (1<<j)) != 0) {
			 la1tokens[j] = true;
		   }
		   if ((jj_la1_1[i] & (1<<j)) != 0) {
			 la1tokens[32+j] = true;
		   }
		   if ((jj_la1_2[i] & (1<<j)) != 0) {
			 la1tokens[64+j] = true;
		   }
		 }
	   }
	 }
	 for (int i = 0; i < 67; i++) {
	   if (la1tokens[i]) {
		 jj_expentry = new int[1];
		 jj_expentry[0] = i;
		 jj_expentries.add(jj_expentry);
	   }
	 }
	 int[][] exptokseq = new int[jj_expentries.size()][];
	 for (int i = 0; i < jj_expentries.size(); i++) {
	   exptokseq[i] = jj_expentries.get(i);
	 }
	 return new ParseException(token, exptokseq, tokenImage);
  }

  private boolean trace_enabled;

/** Trace enabled. */
  final public boolean trace_enabled() {
	 return trace_enabled;
  }

  private int trace_indent = 0;
/** Enable tracing. */
  final public void enable_tracing() {
	 trace_enabled = true;
  }

/** Disable tracing. */
  final public void disable_tracing() {
	 trace_enabled = false;
  }

  protected void trace_call(String s) {
	 if (trace_enabled) {
	   for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
	   System.out.println("Call:	" + s);
	 }
	 trace_indent = trace_indent + 2;
  }

  protected void trace_return(String s) {
	 trace_indent = trace_indent - 2;
	 if (trace_enabled) {
	   for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
	   System.out.println("Return: " + s);
	 }
  }

  protected void trace_token(Token t, String where) {
	 if (trace_enabled) {
	   for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
	   System.out.print("Consumed token: <" + tokenImage[t.kind]);
	   if (t.kind != 0 && !tokenImage[t.kind].equals("\"" + t.image + "\"")) {
		 System.out.print(": \"" + TokenMgrError.addEscapes(t.image) + "\"");
	   }
	   System.out.println(" at line " + t.beginLine + " column " + t.beginColumn + ">" + where);
	 }
  }

  protected void trace_scan(Token t1, int t2) {
	 if (trace_enabled) {
	   for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
	   System.out.print("Visited token: <" + tokenImage[t1.kind]);
	   if (t1.kind != 0 && !tokenImage[t1.kind].equals("\"" + t1.image + "\"")) {
		 System.out.print(": \"" + TokenMgrError.addEscapes(t1.image) + "\"");
	   }
	   System.out.println(" at line " + t1.beginLine + " column " + t1.beginColumn + ">; Expected token: <" + tokenImage[t2] + ">");
	 }
  }

}
